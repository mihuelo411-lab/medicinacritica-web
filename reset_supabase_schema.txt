/* ⚠️ Script maestro: crea/actualiza el esquema sin borrar datos existentes.
   Ejecuta en el editor SQL de Supabase bajo tu proyecto. */

DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'user_role') THEN
    CREATE TYPE user_role AS ENUM ('admin', 'medico', 'residente');
  END IF;
END
$$;

ALTER TYPE user_role ADD VALUE IF NOT EXISTS 'admin';
ALTER TYPE user_role ADD VALUE IF NOT EXISTS 'medico';
ALTER TYPE user_role ADD VALUE IF NOT EXISTS 'residente';

CREATE TABLE IF NOT EXISTS patients (
  id               SERIAL PRIMARY KEY,
  name             VARCHAR(100) NOT NULL,
  dni              TEXT NOT NULL UNIQUE,
  hc               TEXT NOT NULL UNIQUE,
  age              INTEGER NOT NULL,
  sex              TEXT NOT NULL,
  address          TEXT,
  occupation       TEXT,
  phone            TEXT,
  family_contact   TEXT,
  place_of_birth   TEXT,
  insurance_type   TEXT,
  created_at       TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at       TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  is_synced        BOOLEAN NOT NULL DEFAULT FALSE
);

ALTER TABLE IF EXISTS public.patients
  ADD COLUMN IF NOT EXISTS address TEXT,
  ADD COLUMN IF NOT EXISTS occupation TEXT,
  ADD COLUMN IF NOT EXISTS phone TEXT,
  ADD COLUMN IF NOT EXISTS family_contact TEXT,
  ADD COLUMN IF NOT EXISTS place_of_birth TEXT,
  ADD COLUMN IF NOT EXISTS insurance_type TEXT,
  ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ADD COLUMN IF NOT EXISTS is_synced BOOLEAN NOT NULL DEFAULT FALSE;

CREATE TABLE IF NOT EXISTS admissions (
  id               SERIAL PRIMARY KEY,
  patient_id       INTEGER NOT NULL REFERENCES patients(id) ON DELETE CASCADE,
  admission_date   TIMESTAMPTZ NOT NULL,
  sofa_score       DOUBLE PRECISION,
  apache_score     DOUBLE PRECISION,
  nutric_score     DOUBLE PRECISION,
  sofa_mortality   TEXT,
  apache_mortality TEXT,
  diagnosis        TEXT,
  signs_symptoms   TEXT,
  time_of_disease  TEXT,
  illness_start    TEXT,
  illness_course   TEXT,
  story            TEXT,
  physical_exam    TEXT,
  plan             TEXT,
  bp               TEXT,
  hr               TEXT,
  rr               TEXT,
  o2_sat           TEXT,
  temp             TEXT,
  vitals_json      JSONB,
  procedures       TEXT,
  bed_number       INTEGER,
  discharged_at    TIMESTAMPTZ,
  uci_priority     TEXT,
  created_at       TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  is_synced        BOOLEAN NOT NULL DEFAULT FALSE
);

ALTER TABLE IF EXISTS public.admissions
  ADD COLUMN IF NOT EXISTS sofa_score DOUBLE PRECISION,
  ADD COLUMN IF NOT EXISTS apache_score DOUBLE PRECISION,
  ADD COLUMN IF NOT EXISTS nutric_score DOUBLE PRECISION,
  ADD COLUMN IF NOT EXISTS sofa_mortality TEXT,
  ADD COLUMN IF NOT EXISTS apache_mortality TEXT,
  ADD COLUMN IF NOT EXISTS diagnosis TEXT,
  ADD COLUMN IF NOT EXISTS signs_symptoms TEXT,
  ADD COLUMN IF NOT EXISTS time_of_disease TEXT,
  ADD COLUMN IF NOT EXISTS illness_start TEXT,
  ADD COLUMN IF NOT EXISTS illness_course TEXT,
  ADD COLUMN IF NOT EXISTS story TEXT,
  ADD COLUMN IF NOT EXISTS physical_exam TEXT,
  ADD COLUMN IF NOT EXISTS plan TEXT,
  ADD COLUMN IF NOT EXISTS bp TEXT,
  ADD COLUMN IF NOT EXISTS hr TEXT,
  ADD COLUMN IF NOT EXISTS rr TEXT,
  ADD COLUMN IF NOT EXISTS o2_sat TEXT,
  ADD COLUMN IF NOT EXISTS temp TEXT,
  ADD COLUMN IF NOT EXISTS vitals_json JSONB,
  ADD COLUMN IF NOT EXISTS procedures TEXT,
  ADD COLUMN IF NOT EXISTS bed_number INTEGER,
  ADD COLUMN IF NOT EXISTS discharged_at TIMESTAMPTZ,
  ADD COLUMN IF NOT EXISTS uci_priority TEXT,
  ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ADD COLUMN IF NOT EXISTS is_synced BOOLEAN NOT NULL DEFAULT FALSE;

CREATE TABLE IF NOT EXISTS evolutions (
  id                SERIAL PRIMARY KEY,
  admission_id      INTEGER NOT NULL REFERENCES admissions(id) ON DELETE CASCADE,
  date              TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  day_of_stay       INTEGER,
  vitals_json       JSONB,          -- PA, PAM, FC, FR, T, SatO2, FiO2, PaO2, PaFi, VTesp
  vm_settings_json  JSONB,          -- VM_Activa, Guardia, Mode, Vt, FR_Set, PEEP, FiO2_Set, Trigger, Flow, BalanceNum
  vm_mechanics_json JSONB,          -- Ppeak, Pplateau, Cstat, DP
  vm_days           INTEGER,        -- contador de días en VM (persistido si lo calculas)
  vm_active         BOOLEAN,        -- estado VM de la evolución (redundante a VM_Activa)
  subjective        TEXT,
  objective_json    JSONB,
  analysis          TEXT,
  plan              TEXT,
  procedures_note   TEXT,
  diagnosis         TEXT,
  author_name       TEXT,
  author_role       TEXT,
  created_at        TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  is_synced         BOOLEAN NOT NULL DEFAULT FALSE
);

ALTER TABLE IF EXISTS public.evolutions
  ADD COLUMN IF NOT EXISTS day_of_stay INTEGER,
  ADD COLUMN IF NOT EXISTS vitals_json JSONB,
  ADD COLUMN IF NOT EXISTS vm_settings_json JSONB,
  ADD COLUMN IF NOT EXISTS vm_mechanics_json JSONB,
  ADD COLUMN IF NOT EXISTS vm_days INTEGER,
  ADD COLUMN IF NOT EXISTS vm_active BOOLEAN,
  ADD COLUMN IF NOT EXISTS subjective TEXT,
  ADD COLUMN IF NOT EXISTS objective_json JSONB,
  ADD COLUMN IF NOT EXISTS analysis TEXT,
  ADD COLUMN IF NOT EXISTS plan TEXT,
  ADD COLUMN IF NOT EXISTS procedures_note TEXT,
  ADD COLUMN IF NOT EXISTS diagnosis TEXT,
  ADD COLUMN IF NOT EXISTS author_name TEXT,
  ADD COLUMN IF NOT EXISTS author_role TEXT,
  ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ADD COLUMN IF NOT EXISTS is_synced BOOLEAN NOT NULL DEFAULT FALSE;

CREATE TABLE IF NOT EXISTS indication_sheets (
  id             SERIAL PRIMARY KEY,
  admission_id   INTEGER NOT NULL REFERENCES admissions(id) ON DELETE CASCADE,
  payload        TEXT NOT NULL,
  created_at     TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  is_synced      BOOLEAN NOT NULL DEFAULT FALSE
);

ALTER TABLE IF EXISTS public.indication_sheets
  ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ADD COLUMN IF NOT EXISTS is_synced BOOLEAN NOT NULL DEFAULT FALSE;

CREATE TABLE IF NOT EXISTS epicrisis_notes (
  id             SERIAL PRIMARY KEY,
  admission_id   INTEGER NOT NULL REFERENCES admissions(id) ON DELETE CASCADE,
  payload        TEXT NOT NULL,
  created_at     TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at     TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  is_synced      BOOLEAN NOT NULL DEFAULT FALSE
);

ALTER TABLE IF EXISTS public.epicrisis_notes
  ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ADD COLUMN IF NOT EXISTS is_synced BOOLEAN NOT NULL DEFAULT FALSE;

CREATE TABLE IF NOT EXISTS exam_templates (
  id             SERIAL PRIMARY KEY,
  name           TEXT NOT NULL,
  category       TEXT,
  description    TEXT,
  fields_json    JSONB NOT NULL DEFAULT '[]'::jsonb,
  version        INTEGER NOT NULL DEFAULT 1,
  is_archived    BOOLEAN NOT NULL DEFAULT FALSE,
  created_by     TEXT,
  created_at     TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at     TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  is_synced      BOOLEAN NOT NULL DEFAULT FALSE
);

ALTER TABLE IF EXISTS public.exam_templates
  ADD COLUMN IF NOT EXISTS category TEXT,
  ADD COLUMN IF NOT EXISTS description TEXT,
  ADD COLUMN IF NOT EXISTS fields_json JSONB NOT NULL DEFAULT '[]'::jsonb,
  ADD COLUMN IF NOT EXISTS version INTEGER NOT NULL DEFAULT 1,
  ADD COLUMN IF NOT EXISTS is_archived BOOLEAN NOT NULL DEFAULT FALSE,
  ADD COLUMN IF NOT EXISTS created_by TEXT,
  ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ADD COLUMN IF NOT EXISTS is_synced BOOLEAN NOT NULL DEFAULT FALSE;

CREATE TABLE IF NOT EXISTS exam_results (
  id               SERIAL PRIMARY KEY,
  admission_id     INTEGER NOT NULL REFERENCES admissions(id) ON DELETE CASCADE,
  template_id      INTEGER NOT NULL REFERENCES exam_templates(id) ON DELETE CASCADE,
  template_version INTEGER NOT NULL DEFAULT 1,
  recorded_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  values_json      JSONB NOT NULL DEFAULT '{}'::jsonb,
  note             TEXT,
  attachments      TEXT,
  recorded_by      TEXT,
  created_at       TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  is_synced        BOOLEAN NOT NULL DEFAULT FALSE
);

ALTER TABLE IF EXISTS public.exam_results
  ADD COLUMN IF NOT EXISTS template_version INTEGER NOT NULL DEFAULT 1,
  ADD COLUMN IF NOT EXISTS recorded_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ADD COLUMN IF NOT EXISTS values_json JSONB NOT NULL DEFAULT '{}'::jsonb,
  ADD COLUMN IF NOT EXISTS note TEXT,
  ADD COLUMN IF NOT EXISTS attachments TEXT,
  ADD COLUMN IF NOT EXISTS recorded_by TEXT,
  ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  ADD COLUMN IF NOT EXISTS is_synced BOOLEAN NOT NULL DEFAULT FALSE;

ALTER TABLE public.exam_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.exam_results ENABLE ROW LEVEL SECURITY;

CREATE OR REPLACE POLICY "Usuarios autenticados ven plantillas"
  ON public.exam_templates
  FOR SELECT USING (auth.role() = 'authenticated');

CREATE OR REPLACE POLICY "Admins gestionan plantillas"
  ON public.exam_templates
  FOR ALL USING (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE profiles.user_id = auth.uid()
        AND profiles.role = 'admin'
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE profiles.user_id = auth.uid()
        AND profiles.role = 'admin'
    )
  );

CREATE OR REPLACE POLICY "Usuarios autenticados ven resultados"
  ON public.exam_results
  FOR SELECT USING (auth.role() = 'authenticated');

CREATE OR REPLACE POLICY "Usuarios pueden registrar resultados"
  ON public.exam_results
  FOR INSERT WITH CHECK (auth.role() = 'authenticated');

CREATE OR REPLACE POLICY "Usuarios pueden actualizar resultados"
  ON public.exam_results
  FOR UPDATE USING (auth.role() = 'authenticated');

CREATE TABLE IF NOT EXISTS profiles (
  user_id      UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  full_name    TEXT,
  dni          TEXT UNIQUE,
  cmp          TEXT,
  role         user_role NOT NULL DEFAULT 'medico',
  approved_at  TIMESTAMPTZ,
  approved_by  UUID REFERENCES auth.users(id),
  created_at   TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS pending_users (
  user_id        UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  full_name      TEXT,
  dni            TEXT,
  cmp            TEXT,
  email          TEXT,
  requested_role user_role NOT NULL DEFAULT 'medico',
  created_at     TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Índices útiles
CREATE INDEX IF NOT EXISTS idx_admissions_patient ON admissions(patient_id);
CREATE INDEX IF NOT EXISTS idx_evolutions_admission ON evolutions(admission_id);
CREATE INDEX IF NOT EXISTS idx_evolutions_date ON evolutions(date);
CREATE INDEX IF NOT EXISTS idx_indication_sheets_admission ON indication_sheets(admission_id);
CREATE INDEX IF NOT EXISTS idx_epicrisis_notes_admission ON epicrisis_notes(admission_id);
CREATE INDEX IF NOT EXISTS idx_exam_results_admission ON exam_results(admission_id);
CREATE INDEX IF NOT EXISTS idx_exam_results_template ON exam_results(template_id);
CREATE OR REPLACE FUNCTION register_patient_admission(
  p_dni TEXT,
  p_name TEXT,
  p_hc TEXT,
  p_age INTEGER,
  p_sex TEXT,
  p_address TEXT DEFAULT NULL,
  p_occupation TEXT DEFAULT NULL,
  p_phone TEXT DEFAULT NULL,
  p_family_contact TEXT DEFAULT NULL,
  p_place_of_birth TEXT DEFAULT NULL,
  p_insurance_type TEXT DEFAULT NULL,
  p_bed_number INTEGER DEFAULT NULL,
  p_diagnosis TEXT DEFAULT NULL,
  p_sofa_score DOUBLE PRECISION DEFAULT NULL,
  p_apache_score DOUBLE PRECISION DEFAULT NULL
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_patient_id INTEGER;
  v_admission_id INTEGER;
  v_status TEXT;
BEGIN
  SELECT id INTO v_patient_id FROM patients WHERE dni = p_dni LIMIT 1;

  IF v_patient_id IS NULL THEN
    INSERT INTO patients (
      name, dni, hc, age, sex, address, occupation, phone,
      family_contact, place_of_birth, insurance_type, created_at, updated_at, is_synced
    ) VALUES (
      p_name, p_dni, p_hc, COALESCE(p_age, 0), COALESCE(p_sex, 'Desconocido'),
      p_address, p_occupation, p_phone, p_family_contact, p_place_of_birth,
      p_insurance_type, NOW(), NOW(), TRUE
    )
    RETURNING id INTO v_patient_id;
    v_status := 'NUEVO';
  ELSE
    UPDATE patients
       SET name = COALESCE(p_name, name),
           hc = COALESCE(NULLIF(p_hc, ''), hc),
           age = COALESCE(p_age, age),
           sex = COALESCE(p_sex, sex),
           address = COALESCE(p_address, address),
           occupation = COALESCE(p_occupation, occupation),
           phone = COALESCE(p_phone, phone),
           family_contact = COALESCE(p_family_contact, family_contact),
           place_of_birth = COALESCE(p_place_of_birth, place_of_birth),
           insurance_type = COALESCE(p_insurance_type, insurance_type),
           updated_at = NOW()
     WHERE id = v_patient_id;
    v_status := 'REINGRESO';
  END IF;

  -- Cierra admisiones previas abiertas del mismo paciente
  UPDATE admissions
     SET discharged_at = NOW()
   WHERE patient_id = v_patient_id
     AND discharged_at IS NULL;

  INSERT INTO admissions (
    patient_id, admission_date, diagnosis, sofa_score, apache_score,
    bed_number, nutric_score, created_at, is_synced
  ) VALUES (
    v_patient_id,
    NOW(),
    p_diagnosis,
    p_sofa_score,
    p_apache_score,
    p_bed_number,
    NULL,
    NOW(),
    TRUE
  )
  RETURNING id INTO v_admission_id;

  RETURN jsonb_build_object(
    'status', v_status,
    'patient_id', v_patient_id,
    'admission_id', v_admission_id
  );
END;
$$;


-- ==========================================
-- SOLUCIÓN AUTOMÁTICA DE USUARIOS (TRIGGERS)
-- ==========================================

-- 1. Función que maneja el nuevo usuario
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
declare
  v_role user_role := 'medico'; -- Rol por defecto
begin
  -- Intentar extraer el rol de los metadatos si existe, o usar default
  if new.raw_user_meta_data->>'requested_role' is not null then
    begin
      v_role := (new.raw_user_meta_data->>'requested_role')::user_role;
    exception when others then
      v_role := 'medico';
    end;
  end if;

  -- Insertar en public.profiles
  insert into public.profiles (user_id, full_name, dni, cmp, role, created_at)
  values (
    new.id,
    new.raw_user_meta_data->>'full_name',
    new.raw_user_meta_data->>'dni',
    new.raw_user_meta_data->>'cmp',
    v_role,
    now()
  )
  on conflict (user_id) do nothing; -- Si ya existe, no fallar

  -- Insertar en public.pending_users (para el flujo de aprobación)
  insert into public.pending_users (user_id, full_name, dni, cmp, email, requested_role, created_at)
  values (
    new.id,
    new.raw_user_meta_data->>'full_name',
    new.raw_user_meta_data->>'dni',
    new.raw_user_meta_data->>'cmp',
    new.email,
    v_role,
    now()
  )
  on conflict (user_id) do nothing;

  return new;
end;
$$;

-- 2. Crear el trigger solo si no existe
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_trigger
    WHERE tgname = 'on_auth_user_created'
  ) THEN
    CREATE TRIGGER on_auth_user_created
      AFTER INSERT ON auth.users
      FOR EACH ROW
      EXECUTE PROCEDURE public.handle_new_user();
  END IF;
END;
$$;
-- ================================================
-- REPORTES MENSUALES DE PROCEDIMIENTOS + STORAGE
-- ================================================

create table if not exists public.procedure_reports (
  id bigserial primary key,
  period_year int not null,
  period_month int not null,
  csv_data text not null,
  storage_path text, -- Ruta relativa dentro del bucket (ej. 2025/12/file.xlsx)
  created_by uuid references auth.users(id),
  created_at timestamptz default now()
);

alter table public.procedure_reports enable row level security;

create or replace policy "Usuarios autenticados pueden leer reportes"
  on public.procedure_reports
  for select using (auth.role() = 'authenticated');

create or replace policy "Solo RPC inserta reportes"
  on public.procedure_reports
  for insert with check (false);

insert into storage.buckets (id, name, public)
values ('reports', 'reports', true)
on conflict (id) do nothing;

create or replace policy "reports public read"
  on storage.objects for select
  using (bucket_id = 'reports');

create or replace policy "reports authenticated upload"
  on storage.objects for insert to authenticated
  with check (bucket_id = 'reports');

create or replace policy "reports authenticated update"
  on storage.objects for update to authenticated
  using (bucket_id = 'reports')
  with check (bucket_id = 'reports');

create or replace function public.generate_procedure_report(
  p_year int,
  p_month int
)
returns public.procedure_reports
language plpgsql
security definer
set search_path = public
as $$
declare
  v_start date := make_date(p_year, p_month, 1);
  v_end date := (v_start + interval '1 month');
  v_header text := 'FECHA y/ HORA;CAMA;PACIENTE;HC;DIAGNÓSTICO;PROCEDIMIENTO;ASISTENTE;RESIDENTE;ORIGEN;NOTA';
  v_rows text;
  v_csv text;
  v_report public.procedure_reports;
begin
  if p_year is null or p_month is null then
    raise exception 'Debe indicar año y mes';
  end if;

  with procedure_rows as (
    select
      pp.performed_at,
      coalesce(ad.bed_number::text, '-') as bed_label,
      coalesce(pa.name, 'Desconocido') as patient_name,
      coalesce(pa.hc, '-') as hc_text,
      coalesce(replace(ad.diagnosis, E'\n', ' '), '-') as diagnosis_text,
      pp.procedure_name,
      coalesce(pp.assistant, '') as assistant_name,
      coalesce(pp.resident, '') as resident_name,
      case
        when coalesce(pp.origin, '') = '' then 'SIN ORIGEN'
        when pp.guardia is not null then initcap(pp.origin) || ' - ' || pp.guardia
        else initcap(pp.origin)
      end as origin_label,
      coalesce(replace(pp.note, E'\n', ' '), '') as note_text
    from public.performed_procedures pp
    join public.admissions ad on ad.id = pp.admission_id
    join public.patients pa on pa.id = ad.patient_id
    where pp.performed_at >= v_start
      and pp.performed_at < v_end
    union all
    select
      ep.performed_at,
      coalesce(ep.service_room, 'Interconsulta') as bed_label,
      coalesce(pa.name, 'Desconocido') as patient_name,
      coalesce(pa.hc, '-') as hc_text,
      coalesce(replace(ep.diagnosis, E'\n', ' '), '-') as diagnosis_text,
      coalesce(ep.procedure_name, pc.name, 'Procedimiento') as procedure_name,
      coalesce(ep.assistant_name, '') as assistant_name,
      coalesce(ep.resident_name, '') as resident_name,
      case
        when coalesce(ep.service_room, '') = ''
          then 'INTERCONSULTA'
        else 'Interconsulta - ' || initcap(ep.service_room)
      end as origin_label,
      coalesce(replace(ep.note, E'\n', ' '), '') as note_text
    from public.external_procedures ep
    join public.patients pa on pa.id = ep.patient_id
    left join public.procedure_catalog pc on pc.id = ep.procedure_catalog_id
    where ep.performed_at >= v_start
      and ep.performed_at < v_end
  )
  select string_agg(
           format('%s;%s;%s;%s;%s;%s;%s;%s;%s;%s',
                  to_char(r.performed_at, 'DD/MM/YYYY HH24:MI'),
                  r.bed_label,
                  r.patient_name,
                  r.hc_text,
                  r.diagnosis_text,
                  r.procedure_name,
                  r.assistant_name,
                  r.resident_name,
                  r.origin_label,
                  r.note_text),
           E'\n')
    into v_rows
    from procedure_rows r;

  v_csv := v_header || E'\n' || coalesce(v_rows, '');

  insert into public.procedure_reports(period_year, period_month, csv_data, created_by)
  values (p_year, p_month, v_csv, auth.uid())
  returning * into v_report;

  return v_report;
end;
$$;
-- ==========================================
-- GESTIÓN DE PROCEDIMIENTOS (CATÁLOGO Y EXTERNOS)
-- Ejecuta este script en Supabase SQL Editor
-- ==========================================

-- 1. Tabla: Catálogo de Procedimientos
-- Define qué procedimientos existen para ser seleccionados
create table if not exists public.procedure_catalog (
  id serial primary key,
  code text unique,                -- Código interno o CPT (ej. 'CVC-001')
  name text not null,              -- Nombre corto (ej. 'Catéter Venoso Central')
  description_template text,       -- Plantilla de nota (ej. 'Se realiza asepsia con clorhexidina...')
  category text default 'general', -- 'uci', 'interconsulta', 'enfermeria'
  created_at timestamptz default now()
);

-- 2. Tabla: Procedimientos Externos (Interconsultas / Fuera de UCI)
-- Registra procedimientos hechos a pacientes que no necesariamente están ingresados/admitidos actualmente en la UCI
create table if not exists public.external_procedures (
  id serial primary key,
  patient_id integer not null references public.patients(id) on delete cascade,
  procedure_catalog_id integer references public.procedure_catalog(id),
  
  -- Campos Específicos para Reporte Excel
  -- "FECHA y/ HORA" -> performed_at
  performed_at timestamptz default now(),
  
  -- "# CAMA- SERVICIO" -> service_room
  service_room text, 
  
  -- "DIAGNÓSTICO" -> diagnosis (Snapshot del momento)
  diagnosis text,
  
  -- "PROCEDIMIENTO" -> procedure_name (Si es custom o copia del catalogo)
  procedure_name text, 
  
  -- "ASISTENTE" (Médico Asistente / Supervisor)
  assistant_name text,
  
  -- "RESIDENTE" (Médico Residente que realiza)
  resident_name text,

  note text, -- Detalle del procedimiento realizado (rellenado con la plantilla)
  
  -- Auditoria del sistema
  created_by uuid references auth.users(id),
  created_at timestamptz default now()
);

create table if not exists public.performed_procedures (
  id serial primary key,
  admission_id integer not null references public.admissions(id) on delete cascade,
  procedure_id integer references public.procedure_catalog(id),
  procedure_name text not null,
  performed_at timestamptz not null default now(),
  assistant text,
  resident text,
  origin text,
  guardia text,
  note text,
  created_at timestamptz not null default now(),
  is_synced boolean not null default false
);

-- Índices
create index if not exists idx_external_procedures_patient on public.external_procedures(patient_id);
create index if not exists idx_external_procedures_date on public.external_procedures(performed_at);
create index if not exists idx_performed_procedures_admission on public.performed_procedures(admission_id);
create index if not exists idx_performed_procedures_performed_at on public.performed_procedures(performed_at);
create index if not exists idx_performed_procedures_origin_guardia on public.performed_procedures(origin, guardia);

-- 3. Habilitar RLS (Seguridad)
alter table public.procedure_catalog enable row level security;
alter table public.external_procedures enable row level security;

alter table if exists public.external_procedures
  add column if not exists service_room text;
alter table if exists public.external_procedures
  add column if not exists diagnosis text;
alter table if exists public.external_procedures
  add column if not exists procedure_name text;
alter table if exists public.external_procedures
  add column if not exists assistant_name text;
alter table if exists public.external_procedures
  add column if not exists resident_name text;


-- Políticas (Policies)
-- Catalog: Todos pueden leer, Solo Admin puede escribir
create or replace policy "Todos pueden ver catalogo" on public.procedure_catalog
  for select using (true);

create or replace policy "Solo admin modifica catalogo" on public.procedure_catalog
  for all using (
    exists (
      select 1 from public.profiles
      where profiles.user_id = auth.uid()
      and profiles.role = 'admin'
    )
  )
  with check (
    exists (
      select 1 from public.profiles
      where profiles.user_id = auth.uid()
      and profiles.role = 'admin'
    )
  );

-- External Procedures: Autenticados pueden ver y crear
create or replace policy "Usuarios autenticados ven procedimientos" on public.external_procedures
  for select using (auth.role() = 'authenticated');

create or replace policy "Usuarios autenticados crean procedimientos" on public.external_procedures
  for insert with check (auth.role() = 'authenticated');

create or replace policy "Usuarios autenticados editan propiose" on public.external_procedures
  for update using (auth.uid() = created_by);

-- ==========================================
-- ACTUALIZACIÓN: NOTA EN performed_procedures
-- ==========================================
alter table if exists public.performed_procedures
  add column if not exists note text;

alter table if exists public.evolutions
  add column if not exists author_role text;

alter table if exists public.evolutions
  add column if not exists procedures_note text;

-- ==========================================
-- DATOS SEMILLA (EJEMPLOS INICIALES)
-- ==========================================
insert into public.procedure_catalog (code, name, category, description_template)
values 
('CVC', 'Catéter Venoso Central', 'uci', 'Procedimiento realizado bajo medidas de asepsia y antisepsia.\nSitio: Vena Yugular Interna Derecha.\nIntentos: 1.\nComplicaciones: Ninguna.\nConfirmación: Retorno venoso positivo.'),
('INT', 'Intubación Endotraqueal', 'uci', 'Se realiza intubación orotraqueal con tubo N° 7.5.\nFijación: 22 cm arcada dentaria.\nLaringoscopia: Cormack-Lehane I.\nComprobación: Auscultación positiva bilateral simétrica.'),
('LPA', 'Línea Arterial', 'uci', 'Canalización de arteria radial izquierda.\nTest de Allen: Positivo (buena circulación colateral).\nFijación: Sutura seda 3.0.'),
('TORA', 'Toracentesis', 'interconsulta', 'Punción torácica diagnóstica/terapéutica.\nLado: Derecho.\nLíquido obtenido: Cetrino.\nVolumen extraído: 50 cc para muestra.')
on conflict (code) do nothing;

-- 4. Plantillas base para exámenes auxiliares
INSERT INTO public.exam_templates (name, category, description, fields_json)
SELECT
  'Hemograma completo',
  'Laboratorio',
  'Conteo celular y parámetros básicos.',
  '[
    {"id":"leucocitos","label":"Leucocitos","type":"number","unit":"cel/µL","minValue":4000,"maxValue":11000},
    {"id":"neutrofilos","label":"Neutrófilos %","type":"number","unit":"%","minValue":40,"maxValue":75},
    {"id":"hemoglobina","label":"Hemoglobina","type":"number","unit":"g/dL","minValue":12,"maxValue":16},
    {"id":"hematocrito","label":"Hematocrito","type":"number","unit":"%","minValue":36,"maxValue":47},
    {"id":"plaquetas","label":"Plaquetas","type":"number","unit":"x10^3/µL","minValue":150,"maxValue":450}
  ]'::jsonb
WHERE NOT EXISTS (SELECT 1 FROM public.exam_templates WHERE name = 'Hemograma completo');

INSERT INTO public.exam_templates (name, category, description, fields_json)
SELECT
  'Perfil renal',
  'Laboratorio',
  'Urea y creatinina séricas.',
  '[
    {"id":"urea","label":"Urea","type":"number","unit":"mg/dL","minValue":10,"maxValue":50,"isCritical":true},
    {"id":"creatinina","label":"Creatinina","type":"number","unit":"mg/dL","minValue":0.6,"maxValue":1.3,"isCritical":true}
  ]'::jsonb
WHERE NOT EXISTS (SELECT 1 FROM public.exam_templates WHERE name = 'Perfil renal');

INSERT INTO public.exam_templates (name, category, description, fields_json)
SELECT
  'PCR / Marcadores inflamatorios',
  'Laboratorio',
  'Proteína C reactiva sérica.',
  '[
    {"id":"pcr","label":"PCR","type":"number","unit":"mg/L","minValue":0,"maxValue":5,"isCritical":true}
  ]'::jsonb
WHERE NOT EXISTS (SELECT 1 FROM public.exam_templates WHERE name = 'PCR / Marcadores inflamatorios');

INSERT INTO public.exam_templates (name, category, description, fields_json)
SELECT
  'Gasometría arterial',
  'Respiratorio',
  'Análisis básico de gases arteriales.',
  '[
    {"id":"ph","label":"pH","type":"number","minValue":7.35,"maxValue":7.45,"isCritical":true},
    {"id":"pco2","label":"PCO2","type":"number","unit":"mmHg","minValue":35,"maxValue":45},
    {"id":"po2","label":"PO2","type":"number","unit":"mmHg","minValue":80,"maxValue":100,"isCritical":true},
    {"id":"hco3","label":"HCO3","type":"number","unit":"mmol/L","minValue":22,"maxValue":26},
    {"id":"lactato","label":"Lactato","type":"number","unit":"mmol/L","minValue":0.5,"maxValue":2.0,"isCritical":true}
  ]'::jsonb
WHERE NOT EXISTS (SELECT 1 FROM public.exam_templates WHERE name = 'Gasometría arterial');

-- Forzar a PostgREST a recargar el esquema y detectar tablas nuevas
NOTIFY pgrst, 'reload schema';
